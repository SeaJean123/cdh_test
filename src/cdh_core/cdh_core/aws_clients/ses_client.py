# Copyright (C) 2022, Bayerische Motoren Werke Aktiengesellschaft (BMW AG)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from abc import ABC
from abc import abstractmethod
from dataclasses import dataclass
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from logging import getLogger
from time import sleep
from typing import Any
from typing import cast
from typing import Dict
from typing import List
from typing import NewType
from typing import TYPE_CHECKING

from botocore.exceptions import ClientError

from cdh_core.aws_clients.utils import get_error_code
from cdh_core.aws_clients.utils import get_error_message

if TYPE_CHECKING:
    from mypy_boto3_ses import SESClient
    from mypy_boto3_ses.type_defs import RawMessageTypeDef
else:
    SESClient = object
    RawMessageTypeDef = Dict[str, Any]

EmailsPerSecond = NewType("EmailsPerSecond", int)
DEFAULT_RATE = EmailsPerSecond(1)
AWS_RECIPIENT_LIMIT = 50
# AWS has hard limit of 50 recipients
# see https://docs.aws.amazon.com/ses/latest/APIReference/API_SendRawEmail.html
AWS_DAILY_QUOTA_EXCEEDED_ERROR_MSG = "Daily message quota exceeded"
AWS_MAXIMUM_RATE_EXCEEDED_ERROR_MSG = "Maximum sending rate exceeded"
# From https://docs.aws.amazon.com/ses/latest/dg/manage-sending-quotas-errors.html
LOG = getLogger(__name__)


@dataclass(frozen=True)
class Email:
    """An email generated by a template."""

    subject: str
    plain: str
    html: str


class TemplateEmail(ABC):
    """A template that generates emails."""

    @abstractmethod
    def apply(self, recipient: str) -> Email:
        """Set the recipient of the email for the template."""
        raise NotImplementedError


class SesClient:
    """
    Abstracts the boto SES client.

    To actually send emails, you will need a verified email address identity
    https://docs.aws.amazon.com/ses/latest/dg/creating-identities.html#verify-email-addresses-procedure
    and to get out of the sandbox
    https://docs.aws.amazon.com/ses/latest/dg/request-production-access.html
    """

    def __init__(self, boto_ses_client: SESClient):
        self._client = boto_ses_client

    def send_mail(  # pylint: disable=too-many-arguments, too-many-branches
        self,
        recipients: List[str],
        sender: str,
        email_template: TemplateEmail,
        max_rate: EmailsPerSecond = DEFAULT_RATE,
        include_full_recipients_list: bool = False,
        set_high_priority: bool = False,
    ) -> None:
        """
        Send an email to a list of recipients using a given sender identity.

        When choosing a value for max_rate, consider your actual quotas, and that several instances of this client might
        send emails at the same time with the same account. Also consider the timeout of the lambda you are calling
        from (typically 900 seconds). To request limit increases, see
        https://docs.aws.amazon.com/ses/latest/dg/manage-sending-quotas-request-increase.html
        """
        if not recipients:
            LOG.warning("No recipients given, skipping.")
            return
        if include_full_recipients_list:
            if len(recipients) > AWS_RECIPIENT_LIMIT:
                LOG.warning(f"Cannot show the full recipient list. Only the first {AWS_RECIPIENT_LIMIT} will be shown.")
        fail_count = 0
        for recipient in recipients:
            if include_full_recipients_list:
                truncated_recipients = recipients[:AWS_RECIPIENT_LIMIT]
                recipient_list = (
                    truncated_recipients
                    if recipient in truncated_recipients
                    else [recipient] + truncated_recipients[:-1]
                )
            else:
                recipient_list = [recipient]
            try:
                email = email_template.apply(recipient)
                message = RawMessageBuilder.build(recipient_list, sender, email, set_high_priority)
                self._client.send_raw_email(Destinations=[recipient], Source=sender, RawMessage=message)
                LOG.info(f"Successfully sent mail to {recipient}")
            except ClientError as client_error:
                if self._is_daily_limit_error(client_error):
                    raise DailyEmailQuotaExceeded() from client_error
                if self._is_rate_limit_error(client_error):
                    raise MaximalSendRateExceeded(max_rate) from client_error
                if self._is_not_verified_error(client_error):
                    LOG.warning(f"Recipient {recipient} is not verified, could not send email.")
                else:
                    fail_count += 1
                    LOG.warning(f"Could not send mail to {recipient}: {client_error}")
            except Exception as error:  # pylint: disable=broad-except
                fail_count += 1
                LOG.warning(f"Could not send mail to {recipient}: {error}")
            sleep(1 / max_rate)
        if fail_count > 0:
            raise FailedToSendMail(len(recipients), fail_count)

    @staticmethod
    def _is_daily_limit_error(error: ClientError) -> bool:
        return get_error_code(
            error
        ) == "ThrottlingException" and AWS_DAILY_QUOTA_EXCEEDED_ERROR_MSG in get_error_message(error)

    @staticmethod
    def _is_rate_limit_error(error: ClientError) -> bool:
        return get_error_code(
            error
        ) == "ThrottlingException" and AWS_MAXIMUM_RATE_EXCEEDED_ERROR_MSG in get_error_message(error)

    @staticmethod
    def _is_not_verified_error(error: ClientError) -> bool:
        """
        Check whether an error was raised because the recipient is not verified.

        This only occurs for accounts in the sandbox, and is ignored for testing purposes.
        """
        return get_error_code(error) == "MessageRejected" and "Email address is not verified" in get_error_message(
            error
        )


class RawMessageBuilder:
    """Responsible for converting html and plain text versions of an email to a raw message."""

    @staticmethod
    def build(recipients: List[str], sender: str, email: Email, set_high_priority: bool = False) -> RawMessageTypeDef:
        """Format an email as a raw message for SES."""
        child_message = MIMEMultipart("alternative")
        child_message.attach(MIMEText(email.plain, "plain", "utf-8"))
        child_message.attach(MIMEText(email.html, "html", "utf-8"))
        message = MIMEMultipart("mixed")
        message.attach(child_message)
        message["Subject"] = email.subject
        message["From"] = sender
        message["To"] = ", ".join(recipients)
        if set_high_priority:
            message["X-Priority"] = "2"
        return {"Data": cast(bytes, message.as_string())}


class FailedToSendMail(Exception):
    """Signals the client failed to send the mail to some recipients."""

    def __init__(self, total: int, failed: int):
        super().__init__(f"Could not send mail to {failed}/{total} recipients. Check the logs for details.")


class DailyEmailQuotaExceeded(Exception):
    """Signals the daily quota of emails has been exceeded."""

    def __init__(self) -> None:
        super().__init__("Daily email quota exceeded. Consider requesting a limit increase.")


class MaximalSendRateExceeded(Exception):
    """Signals the rate of sent emails exceeded the maximum allowed."""

    def __init__(self, max_rate: EmailsPerSecond):
        super().__init__(
            f"Email sending throttled with {max_rate=}."
            "Please try a lower rate, or consider requesting a limit increase."
        )
